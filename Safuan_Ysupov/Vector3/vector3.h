#ifndef VECTOR_H
#define VECTOR_H


/*Обобщенное программирование - это создание кода. работающего
с разными типами. заданными в виде аргументов, причем эти типы
должны соответствовать специфическим синтаксическим и семантическим требованиям.*/

/*Обобщенное программирование поддерживается шаблонами, основываясь на разрешении вызовов времени компиляции. */

/*Объектно-ориентированное программирован11е поддерживается
иерархиями классов и виртуальными функциями. основываясь
на разрешении вызовов времени выполнения. */

/*Используйте шаблоны. когда важную роль играет производительность программы (например. при интенсивных вычислениях или в программах реального времени; подробнее об этом речь
пойдет в главах 24 и 25).*/

/*Используйте шаблоны. когда важна гибкость сочетания информации
из разных типов (например. в стандартной библиотеке С++: эта тема
будет обсуждаться в главах 20 и 21 ). */

#include <algorithm>
#include <iostream>
#include <memory>
#include <initializer_list>
#include <string>
#include <stdexcept>
#include <stdio.h>

using namespace std;

/*необходимо
пред,усмотреть объект. который будет владеть объектом класса vector<int>
и сможет его удалить, если возникнет исключение. В заголовочном файле <memory> стандартной библиотеки на этот случай предоставлен класс
unique_ptr.*/

//в итоге для работы с встроенными классами:
//allocator Создание контейнера с пользовательским распределителем
//дает возможность управлять выделением и освобождением памяти
//для элементов контейнера.



// класс vector _ base работает с памятью, а не
//с типизированными объектами.
template<typename T, typename A>struct vector_base
{
    A alloc;   //Распределение памяти
    T* elem;   //Начало выделенной памяти
    size_t sz;    //Количество элементов
    size_t space; //Размер выделенной памяти

    vector_base();
    vector_base(vector_base &&a);
    vector_base(const A& a, size_t s);
    vector_base& operator = (vector_base&& a);
    ~vector_base();
};

//template<class T> тоже самое template<typename T>
template<typename T, typename A = allocator<T>>
class Vector : private vector_base<T, A> {
    /*
     * Инвариант:
     * для 0<=n<sz значение elem[n] является n-м элементом
     * sz<=space;
     * усли sz<space, то после elem[sz-1] есть место
     * для (space-sz) чисел типа double
    */
public:

    Vector():vector_base<T, A>(A(), 0) { } //конструктор по умолчанию

    // Конструктор: размещаает в памяти s чисел
    // типа double, направляет на них указатель
    // elem и сохраняет s в член sz
    //Конструктор со словом explicit не допускает неявные преобразования
    Vector(size_t s);

    Vector(const Vector& a); //Конструктор копирования (копирующая инициализация)
    Vector& operator=(const Vector& a); //Конструктор присваивания (копирующее присваивание)

    Vector(Vector&& a);          //Перемещающий конструктор
    Vector& operator=(Vector&& a); //Перемещающее присваивание

    T &operator[](int n) //Для неконстантных векторов, Доступ без проверки
    { return this->elem[n]; }

    const T& operator[] (int n) const //для константных векторов без проверки
    { return this->elem[n]; }

    //Конструктор со списком инициализации
    Vector(initializer_list<T> lst);

    size_t size() const //Текущий размер
    { return this->sz; }

    size_t capacity() const //Узнать размер доступной памяти (Сколько свободного места осталось)
    { return this->space; }

    void reserve(size_t newalloc); //добавляет память для новых элементов
    void resize(size_t newsize, T val=T()); //resize () добавляет / удаляет элементы в зависимости от заданного им размера
    void push_back(const T& val); //Увеличивает размер вектора на 1
                              //инициализирует новый элемент значением d

    T get(int n) const; //Чтение
    void set(int n, T v); //Запись

    ~Vector();        //Деструктор, освобождает память
};




#endif // VECTOR_H
